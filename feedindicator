#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#		feedindicator
#       Copyright (C) 2010-2011 Dave Gardner <eunbolt@gmail.com> & Michael Judge <email@clickopen.co.uk>
#
#		This program is free software: you can redistribute it and/or modify
#		it under the terms of the GNU General Public License as published by
#		the Free Software Foundation, either version 3 of the License, or
#		(at your option) any later version.
#
#		This program is distributed in the hope that it will be useful,
#		but WITHOUT ANY WARRANTY; without even the implied warranty of
#		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#		GNU General Public License for more details.
#
#		You should have received a copy of the GNU General Public License
#		along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# [SNIPPET_NAME: Parse an RSS feed]
# [SNIPPET_CATEGORIES: feedparser]  
# [SNIPPET_DESCRIPTION: Parse and iterate over the items in an RSS feed]
# [SNIPPET_AUTHOR: Tim Voet <tim.voet@gmail.com>]
# [SNIPPET_DOCS: http://www.feedparser.org/docs/introduction.html]
# [SNIPPET_LICENSE: GPL]

# need python-feedparser and app-indicator(should come with ubuntu 10.04 and above)

import pygtk
pygtk.require('2.0')
import glib
import gtk
import appindicator
import feedparser
import gc
import hashlib
import os
import pynotify
import string
import sys
import urllib
import webbrowser
import gconf
import time
import gobject
import shutil
import sqlite3 as lite
from threading import Thread
from time import sleep
from gconf import VALUE_BOOL, VALUE_INT, VALUE_STRING, VALUE_FLOAT
from types import BooleanType, StringType, IntType, FloatType
from configobj import ConfigObj

# clear out the html element list so all are removed
feedparser._HTMLSanitizer.acceptable_elements = []

# common name used for file paths, gconf and indicator identifier
app_identifier = 'feedindicator'

# indicator icon names
app_indicator_icon = 'indicator-feedindicator'
app_indicator_icon_attention = 'indicator-feedindicator-attention'

# XDG config
xdg_config_dir = glib.get_user_config_dir()
app_config_dir = os.path.join(xdg_config_dir, app_identifier)

# XDG cache
xdg_cache_dir = glib.get_user_cache_dir()
app_cache_dir = os.path.join(xdg_cache_dir, app_identifier)

# /usr/share/
app_share_dir = '/usr/share/'+app_identifier+'/'
app_icon = os.path.join(app_share_dir, 'feedindicator-icon.png')
app_logo = os.path.join(app_share_dir, 'feedindicator-logo.png')
app_language_dir = os.path.join(app_share_dir, 'languages/')

# database
app_database = os.path.join(app_config_dir, 'feedindicator.db')

# language properties file
app_language_file = os.path.join(app_config_dir, 'language.properties')

# autostart file
app_autostart_folder = os.path.join(xdg_config_dir, 'autostart')
app_autostart_file = os.path.join(app_autostart_folder, app_identifier+'.desktop')

# general app info mostly used in about dialog
app_name = 'Feedindicator'
app_version = '1.03'
app_comments = 'RSS feed updates in the indicator area'
app_copyright = 'Copyright (C) 2010-2011 Dave Gardner & Michael Judge'
app_website = 'http://code.google.com/p/feedindicator/'
app_license = (('This program is free software: you can redistribute it and/or modify\n'+
'it under the terms of the GNU General Public License as published by\n'+
'the Free Software Foundation, either version 3 of the License, or\n'+
'(at your option) any later version.\n'+
'\n'+
'This program is distributed in the hope that it will be useful,\n'+
'but WITHOUT ANY WARRANTY; without even the implied warranty of\n'+
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n'+
'GNU General Public License for more details.\n'+
'\n'+
'You should have received a copy of the GNU General Public License\n'+
'along with this program.  If not, see <http://www.gnu.org/licenses/>.'))
app_authors = ['Dave Gardner <eunbolt@gmail.com>','Michael Judge <email@clickopen.co.uk>']
app_documenters = ['Dave Gardner <eunbolt@gmail.com>','Michael Judge <email@clickopen.co.uk>']

# default autostart status
autostart = False

# default feed refresh time (minutes*seconds)
refreshtime = 30*60

# default stop the timer from running?
stoptimer = False

# default menu items to show per feed
itemsperfeed = 5

# default put feed items in submenus
usesubmenus = False

# default show notification popups
shownotifications = True

# default show notification popups at begining and end of update
shownotificationsupdate = True

# default sound for new posts
sound = "/usr/bin/mplayer -ao alsa /usr/share/sounds/ubuntu/stereo/message.ogg"

# default position of the feeds top or button of the menu
feedstop = True

# default shows feeds with no unread posts
unreadfeeds = True

# language properties
language_properties = None



##################################################
###############       SQLite       ###############
##################################################
class SQLite:
	def get_con():
		return self._con

	con = property(get_con)

	def __init__(self):
		self._con = None

	def open(self, path):
		"""opens a new connection"""
		try:
			self._con = lite.connect(path)
		except lite.Error, e:
			print e

	def close(self):
		"""closes the current connection"""
		if self._con:
			try:
				self._con.close()
			except lite.Error, e:
				print e

	def execute(self, query, data=()):
		"""executes the given query and returns the results"""
		if self._con:
			try:
				cur = self._con.cursor()
				if data == ():
					cur.execute(query)
				else:
					cur.execute(query, data)
				rows = cur.fetchall()
				return rows
			except lite.Error, e:
				print e

		return None

	def executemany(self, query, data):
		"""executes the given query with executemany()"""
		if self._con:
			try:
				cur = self._con.cursor()
				cur.executemany(query, data)
			except lite.Error, e:
				print e

	def commit(self):
		"""commits changes to the database"""
		if self._con:
			try:
				self._con.commit()
			except lite.Error, e:
				self._con.rollback()
				print e

	def contains(self, query, data=()):
		"""checks wheter the given query has results or not"""
		if self._con:
			try:
				cur = self._con.cursor()
				if data == ():
					cur.execute(query)
				else:
					cur.execute(query, data)
				rows = cur.fetchone()

				if rows:
					return True;
				else:
					return False;
			except lite.Error, e:
				print e



##################################################
###############        Exit        ###############
##################################################
class Exit:
	def __init__(self, widget):
		sys.exit()



##################################################
###############        GConf       ###############
##################################################
class GConf:
	def __init__ (self, appname, allowed={}):
		self._domain = '/apps/%s/' % appname
		self._allowed = allowed
		self._gconf_client = gconf.client_get_default ()

	def __getitem__ (self, attr):
		return self.get_value (attr)

	def __setitem__ (self, key, val):
		allowed = self._allowed
		if allowed.has_key(key):
			if not key in allowed[key]:
				good = ', '.join (allowed[key])
				return False
		self.set_value (key, val)

	def _get_type (self, key):
		KeyType = type (key)
		if KeyType == BooleanType:
			return 'bool'
		elif KeyType == StringType:
			return 'string'
		elif KeyType == IntType:
			return 'int'
		elif KeyType == FloatType:
			return 'float'
		else:
			return None

	# Public functions
	def set_allowed (self, allowed):
		self._allowed = allowed

	def set_domain (self, domain):
		self._domain = domain

	def get_domain (self):
		return self._domain

	def get_gconf_client (self):
		return self._gconf_client

	def get_value (self, key):
		"""returns the value of key 'key' """
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		value = self._gconf_client.get(self._domain + key)
		if value is not None:
			ValueType = value.type
			if ValueType == VALUE_BOOL:
				return value.get_bool()
			elif ValueType == VALUE_INT:
				return value.get_int()
			elif ValueType == VALUE_STRING:
				return value.get_string()
			elif ValueType == VALUE_FLOAT:
				return value.get_float()
			else:
				return None
		else:
			return None

	def set_value (self, key, value):
		"""sets the value of key 'key' to 'value' """
		value_type = self._get_type(value)
		if value_type is not None:
			if '/' in key:
				raise 'GConfError', 'key must not contain /'
			func = getattr (self._gconf_client, 'set_' + value_type)
			apply(func, (self._domain + key, value))

	def get_string (self, key):
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		return self._gconf_client.get_string(self._domain + key)

	def set_string (self, key, value):
		if type (value) != StringType:
			raise 'GConfError', 'value must be a string'
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		self._gconf_client.set_string(self._domain + key, value)

	def get_bool (self, key):
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		return self._gconf_client.get_bool(self._domain + key)

	def set_bool (self, key, value):
		if type (value) != IntType and (key != 0 or key != 1):
			raise 'GConfError', 'value must be a boolean'
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		self._gconf_client.set_bool(self._domain + key, value)

	def get_int (self, key):
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		return self._gconf_client.get_int(self._domain + key)

	def set_int (self, key, value):
		if type (value) != IntType:
			raise 'GConfError', 'value must be an int'
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		self._gconf_client.set_int(self._domain + key, value)

	def get_float (self, key):
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		return self._gconf_client.get_float(self._domain + key)

	def set_float (self, key, value):
		if type (value) != FloatType:
			raise 'GConfError', 'value must be a float'
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		self._gconf_client.set_float(self._domain + key, value)



##################################################
###############     FeedThread     ###############
##################################################
class FeedThread(Thread):
	def run(self):
		"""updates all feeds in the database und updates the infos"""
		sq = SQLite()
		sq.open(app_database)

		feeds = sq.execute('select feed_url, title, url, img from feeds')
		if len(feeds) > 0:
			for feed in feeds:
				feedinfo = self.parse_feed(feed[0])

				if feedinfo['success']:
					if feed[1] == None:
						sq.execute('update feeds set title=? where feed_url=?', (unicode(feedinfo['feeddata']['title']), feed[0]))
					if not feed[2] == unicode(feedinfo['feeddata']['link']):
						sq.execute('update feeds set url=? where feed_url=?', (unicode(feedinfo['feeddata']['link']), feed[0]))
					if not unicode(feedinfo['feeddata']['img']) == 'None':
						sq.execute('update feeds set img=? where feed_url=?', (unicode(feedinfo['feeddata']['img']), feed[0]))

					items = ()
					posts = ()
					for postdata in feedinfo['postdata']:
						if not postdata['date'] == '':
							md5 = hashlib.md5(str(postdata['date']) + '@' + str(postdata['title'])).hexdigest()
							posts = posts + (md5,)
							if not sq.contains('select * from posts where id=?', (md5,)):
								items = items + ((md5, unicode(postdata['link']), unicode(postdata['title']), unicode(feed[0])), )
						else:
							md5 = hashlib.md5(str(postdata['link'])).hexdigest()
							posts = posts + (md5,)
							if not sq.contains('select * from posts where id=?', (md5,)):
								items = items + ((md5, unicode(postdata['link']), unicode(postdata['title']), unicode(feed[0])), )

					if not items == ():
						sq.executemany('insert into posts (id, post_url, title, feed_url) values (?,?,?,?)', items)

					placeholder= '?'
					placeholders= ', '.join(placeholder for unused in posts)
					posts = posts + (feed[0],)
					sq.execute('delete from posts where read=\'true\' and id not in (%s) and feed_url=?' % placeholders, posts)

		sq.commit()
		sq.close()

		gobject.idle_add(indicator.finnished_update)

	def parse_feed(self, url):
		"""parses a feed and returns the infos"""
		feedinfo = {}
		feedinfo['feeddata'] = {}
		feedinfo['postdata'] = []
		feedinfo['success'] = False
		try:
			rssfeed = feedparser.parse(url)
			postdata = []
			for val in rssfeed.entries:
				val.title = string.replace(val.title, '\n', '')
				if len(val.title) > 72:
					substr = val.title[:72]
					substr = substr.rpartition(' ')
					if substr[0] != '':
						val.title = substr[0] + '...'

				date = ''
				if 'published' in val:
					date = val.published
				elif 'updated' in val:
					date = val.updated
				elif 'created' in val:
					date = val.created

				v = {'title': val.title, 'link': val.link, 'date': date}
				postdata.append(v)
			feedinfo['postdata'] = postdata
			feedimg = None
			webimg = None
			if 'image' in rssfeed.feed:
				if 'href' in rssfeed.feed.image:
					webimg = rssfeed.feed.image.href
				elif 'url' in rssfeed.feed.image:
					webimg = rssfeed.feed.image.url
			elif 'logo' in rssfeed.feed:
				webimg = rssfeed.feed.logo
			elif 'icon' in rssfeed.feed:
				webimg = rssfeed.feed.icon
			if webimg != None:
				ext = webimg.rsplit('.', 1)
				if len(ext[1]) > 5 or len(ext[1]) == 0:
					ext[0] = webimg
					ext[1] = 'jpg'
				md5hash = hashlib.md5(str(url)).hexdigest()
				localimg = os.path.join(app_cache_dir, md5hash + '.' + ext[1])
				urllib.urlretrieve(webimg, localimg)
				feedimg = md5hash + '.' + ext[1]
			feedinfo['feeddata'] = {'title': rssfeed.feed.title, 'link': rssfeed.feed.link, 'img': feedimg}
			feedinfo['success'] = True
		except:
			pass

		return feedinfo



##################################################
###############   AddFeedDialog    ###############
##################################################
class AddFeedDialog:
	def __init__(self, widget):
		self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
		self.window.set_size_request(450, 120)
		self.window.set_position(gtk.WIN_POS_CENTER)
		self.window.set_title(language_properties['add_feed'] + ' | ' + app_name)
		self.window.connect('delete_event', self.cancel_dialog)
		self.window.connect('key-press-event', self.keypress)

		vbox = gtk.VBox(False, 10)
		vbox.set_border_width(10)
		self.window.add(vbox)
		vbox.show()

		hboxl = gtk.HBox(False, 0)
		vbox.pack_start(hboxl, False, True, 0)
		hboxl.show()

		label = gtk.Label(language_properties['add_dialog_column'])
		label.set_justify(gtk.JUSTIFY_LEFT)
		label.set_line_wrap(True)
		hboxl.pack_start(label, False, True, 0)
		label.show()

		hbox2 = gtk.HBox(False, 0)
		vbox.pack_start(hbox2, False, True, 0)
		hbox2.show()

		self._textbox = gtk.Entry()
		hbox2.pack_start(self._textbox, True, True, 0)
		self._textbox.connect("activate", self.save_dialog)
		self._textbox.show()

		hbox3 = gtk.HBox(True, 0)
		vbox.pack_end(hbox3, False, True, 5)
		hbox3.show()

		button_cancel = gtk.Button(language_properties['cancel'])
		hbox3.pack_start(button_cancel, True, True, 0)
		button_cancel.connect_object('clicked', self.cancel_dialog, button_cancel)
		button_cancel.show()
		button_save = gtk.Button(language_properties['add'])
		hbox3.pack_start(button_save, True, True, 0)
		button_save.connect_object('clicked', self.save_dialog, None)
		button_save.show()

		self.window.set_keep_above(True)
		self.window.show()

	def cancel_dialog(self, widget, data=None):
		"""cancel dialog"""
		self.window.destroy()

	def save_dialog(self, data):
		"""save feed to config file and close add feed dialog"""
		self.window.set_modal(True)
		sq = SQLite()
		sq.open(app_database)
		sq.execute('insert into feeds (feed_url) values (?)', (unicode(self._textbox.get_text()),))
		sq.commit()
		sq.close()
		self.window.destroy()

		indicator.update_feeds(None, True, False)

	def keypress(self, widget, data):
		"""keypress handler"""
		if data.keyval == gtk.keysyms.Escape:
			self.window.destroy()
		elif data.keyval == gtk.keysyms.Return:
			self.save_dialog(None)



##################################################
###############     AboutDialog    ###############
##################################################
class AboutDialog:
	def __init__(self, widget):
		about = gtk.AboutDialog()
		about.set_logo(gtk.gdk.pixbuf_new_from_file(app_logo))
		about.set_name(app_name)
		about.set_program_name(app_name)
		about.set_version(app_version)
		about.set_comments(app_comments)
		about.set_copyright(app_copyright)
		about.set_license(app_license)
		about.set_website(app_website)
		about.set_website_label(app_website)
		about.set_authors(app_authors)
		about.set_documenters(app_documenters)
		about.run()
		about.destroy()



##################################################
###############  ConfigureDialog   ###############
##################################################
class ConfigureDialog:
	def __init__(self, widget):
		self.refreshtimeset = refreshtime
		self.itemsperfeedset = itemsperfeed
		self.autostartset = autostart
		self.shownotificationsset = shownotifications
		self.shownotificationsupdateset = shownotificationsupdate
		self.usesubmenusset = usesubmenus
		self.feedstopset = feedstop
		self.unreadfeedsset = unreadfeeds
		self.langaugeset = ''

		self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
		self.window.set_size_request(900, 550)
		self.window.set_border_width(10)
		self.window.set_position(gtk.WIN_POS_CENTER)
		self.window.set_title(str(language_properties['configure'] % app_name))
		self.window.connect('delete_event', self.cancel_dialog)
		self.window.connect('key-press-event', self.keypress)

		table = gtk.Table(3,6,False)
		self.window.add(table)

		notebook = gtk.Notebook()
		notebook.set_tab_pos(gtk.POS_LEFT)
		table.attach(notebook, 0,6,0,1)
		notebook.show()

		#Feed List
		frame_feed_list = gtk.Frame(language_properties['feed_list'])
		frame_feed_list.set_border_width(10)
		frame_feed_list.set_size_request(800, 500)
		frame_feed_list.show()

		vbox = gtk.VBox(False, 10)
		vbox.set_border_width(10)
		frame_feed_list.add(vbox)
		vbox.show()

		label = gtk.Label(language_properties['configure_dialog_label'])
		label.set_justify(gtk.JUSTIFY_LEFT)
		label.set_line_wrap(True)
		vbox.pack_start(label, False, True, 0)
		label.show()

		scrolled_window = gtk.ScrolledWindow()
		scrolled_window.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_ALWAYS)
		scrolled_window.set_shadow_type(gtk.SHADOW_IN)
		vbox.pack_start(scrolled_window, True, True, 0)
		scrolled_window.show()

		liststore = gtk.ListStore(str, str, str)

		sq = SQLite()
		sq.open(app_database)

		feeds = sq.execute('select feed_url, title from feeds order by upper(title)')
		for feed in feeds:
			liststore.append([unicode(feed[1]), unicode(feed[0]), unicode(feed[0])])

		sq.close()

		self.treeview = gtk.TreeView(liststore)
		textrenderer = gtk.CellRendererText()
		self.titlecolumn = gtk.TreeViewColumn(language_properties['column_title'])
		self.treeview.append_column(self.titlecolumn)
		self.titlecolumn.pack_start(textrenderer, True)
		self.titlecolumn.add_attribute(textrenderer, 'text', 0)
		textrenderer.set_property('editable', True)
		textrenderer.connect('edited', self.cell_edited, liststore, 0)

		textrenderer = gtk.CellRendererText()
		self.urlcolumn = gtk.TreeViewColumn(language_properties['column_url'])
		self.treeview.append_column(self.urlcolumn)
		self.urlcolumn.pack_start(textrenderer, True)
		self.urlcolumn.add_attribute(textrenderer, 'text', 1)
		textrenderer.set_property('editable', True)
		textrenderer.connect('edited', self.cell_edited, liststore, 1)

		self.treeview.set_headers_clickable(False)
		self.treeview.set_reorderable(True)
		self.treeview.connect('cursor-changed', self.selection_made)
		scrolled_window.add(self.treeview)
		self.treeview.show()

		hbox1 = gtk.HBox(True, 0)
		vbox.pack_start(hbox1, False, True, 0)
		hbox1.show()

		self.button_change = gtk.Button(language_properties['add_new'])
		hbox1.pack_start(self.button_change, True, True, 0)
		self.button_change.connect_object('clicked', self.button_add_clicked, liststore)
		self.button_change.show()
		self.button_remove = gtk.Button(language_properties['remove'])
		hbox1.pack_start(self.button_remove, True, True, 0)
		self.button_remove.connect_object('clicked', self.button_remove_clicked, liststore)
		self.button_remove.set_sensitive(False)
		self.button_remove.show()

		notebook.append_page(frame_feed_list, gtk.Label(language_properties['feed_list']))


		#Feed Options
		frame_feed_options = gtk.Frame(language_properties['feed_options'])
		frame_feed_options.set_border_width(10)
		frame_feed_options.set_size_request(800, 500)
		frame_feed_options.show()

		vbox = gtk.VBox(False, 10)
		vbox.set_border_width(10)
		frame_feed_options.add(vbox)
		vbox.show()

		hbox2sl = gtk.HBox(False, 0)
		vbox.pack_start(hbox2sl, False, True, 0)
		hbox2sl.show()

		self.scaletimerlabel = gtk.Label('')
		hbox2sl.pack_start(self.scaletimerlabel, False, False, 0)
		self.scaletimerlabel.show()

		hbox2s = gtk.HBox(False, 0)
		vbox.pack_start(hbox2s, False, True, 0)
		hbox2s.show()

		adjtimer = gtk.Adjustment(int(self.refreshtimeset/60), 1.0, 90.0, 1.0, 10.0, 0.0)
		adjtimer.connect('value_changed', self.timer_scale)
		scaletimer = gtk.HScale(adjtimer)
		scaletimer.set_draw_value(False)
		scaletimer.set_digits(0)
		hbox2s.pack_start(scaletimer, True, True, 0)
		self.timer_scale(adjtimer)
		scaletimer.show()

		hbox2il = gtk.HBox(False, 0)
		vbox.pack_start(hbox2il, False, True, 0)
		hbox2il.show()

		self.scaleitemslabel = gtk.Label('')
		hbox2il.pack_start(self.scaleitemslabel, False, False, 0)
		self.scaleitemslabel.show()

		hbox2i = gtk.HBox(False, 0)
		vbox.pack_start(hbox2i, False, True, 0)
		hbox2i.show()

		adjitems = gtk.Adjustment(int(self.itemsperfeedset), 1.0, 30.0, 1.0, 10.0, 0.0)
		adjitems.connect('value_changed', self.items_scale)
		scaleitems = gtk.HScale(adjitems)
		scaleitems.set_draw_value(False)
		scaleitems.set_digits(0)
		hbox2i.pack_start(scaleitems, True, True, 0)
		self.items_scale(adjitems)
		scaleitems.show()

		check_usesubmenus = gtk.CheckButton(language_properties['submenu_feed'])
		vbox.pack_start(check_usesubmenus, False, True, 0)
		if usesubmenus:
			check_usesubmenus.set_active(True)
		check_usesubmenus.connect('toggled', self.usesubmenus_toggle)
		check_usesubmenus.show()

		check_feedstop = gtk.CheckButton(language_properties['feeds_top_menu'])
		vbox.pack_start(check_feedstop, False, True, 0)
		if feedstop:
			check_feedstop.set_active(True)
		check_feedstop.connect('toggled', self.feedstop_toggle)
		check_feedstop.show()

		check_unreadfeeds = gtk.CheckButton(language_properties['unread_feeds_menu'])
		vbox.pack_start(check_unreadfeeds, False, True, 0)
		if unreadfeeds:
			check_unreadfeeds.set_active(True)
		check_unreadfeeds.connect('toggled', self.unreadfeeds_toggle)
		check_unreadfeeds.show()

		notebook.append_page(frame_feed_options, gtk.Label(language_properties['feed_options']))


		#Global Options
		frame_feed_options = gtk.Frame(language_properties['global_options'])
		frame_feed_options.set_border_width(10)
		frame_feed_options.set_size_request(800, 500)
		frame_feed_options.show()

		vbox = gtk.VBox(False, 10)
		vbox.set_border_width(10)
		frame_feed_options.add(vbox)
		vbox.show()

		check_autostart = gtk.CheckButton(language_properties['run_startup'])
		vbox.pack_start(check_autostart, False, True, 0)
		if autostart:
			check_autostart.set_active(True)
		check_autostart.connect('toggled', self.autostart_toggle)
		check_autostart.show()

		check_shownotifications = gtk.CheckButton(language_properties['show_notifications'])
		vbox.pack_start(check_shownotifications, False, True, 0)
		if shownotifications:
			check_shownotifications.set_active(True)
		check_shownotifications.connect('toggled', self.shownotifications_toggle)
		check_shownotifications.show()

		self.check_shownotificationsupdate = gtk.CheckButton(language_properties['show_notifications_update'])
		vbox.pack_start(self.check_shownotificationsupdate, False, True, 0)
		if not shownotifications:
			self.check_shownotificationsupdate.set_sensitive(False)
		if shownotificationsupdate:
			self.check_shownotificationsupdate.set_active(True)
		self.check_shownotificationsupdate.connect('toggled', self.shownotificationsupdate_toggle)
		self.check_shownotificationsupdate.show()

		hbox3l = gtk.HBox(False, 0)
		vbox.pack_start(hbox3l, False, True, 0)
		hbox3l.show()

		entrylabel = gtk.Label(language_properties['signal_command'])
		hbox3l.pack_start(entrylabel, False, False, 0)
		entrylabel.set_line_wrap(True)
		entrylabel.show()

		hbox3 = gtk.HBox(True, 0)
		vbox.pack_start(hbox3, False, True, 0)
		hbox3.show()

		self._textbox = gtk.Entry()
		hbox3.pack_start(self._textbox, True, True, 0)
		self._textbox.set_text(sound)
		self._textbox.show()

		hbox4 = gtk.HBox(True, 0)
		vbox.pack_start(hbox4, False, True, 0)
		hbox4.show()

		langaugelabel = gtk.Label(language_properties['choose_language'])
		hbox4.pack_start(langaugelabel, True, True, 0)
		langaugelabel.show()

		language_store = gtk.ListStore(str, str)
		languages = os.listdir(app_language_dir)
		i = 0
		index = 0
		for lang in languages:
			prop = ConfigObj(os.path.join(app_language_dir, lang))
			language_store.append([lang, prop['language']])
			if prop['language'] == language_properties['language']:
				index = i
			i = i + 1

		combobox_language = gtk.ComboBox(language_store)
		cell = gtk.CellRendererText()
		combobox_language.pack_start(cell, True)
		combobox_language.add_attribute(cell, 'text', 1)
		combobox_language.set_active(index)
		combobox_language.connect('changed', self.language_toggle)
		hbox4.pack_start(combobox_language, True, True, 0)
		combobox_language.show()

		notebook.append_page(frame_feed_options, gtk.Label(language_properties['global_options']))

		table.attach(gtk.Label(''), 0,1,1,2)
		button_about = gtk.Button(language_properties['about'])
		table.attach(button_about, 3,4,1,2)
		button_about.connect_object('clicked', AboutDialog, button_about)
		button_about.show()
		button_cancel = gtk.Button(language_properties['cancel'])
		table.attach(button_cancel, 4,5,1,2)
		button_cancel.connect_object('clicked', self.cancel_dialog, button_cancel)
		button_cancel.show()
		button_save = gtk.Button(language_properties['save'])
		button_save.connect('clicked', self.save_dialog, liststore)
		table.attach(button_save, 5,6,1,2)
		button_save.show()

		table.show()
		self.window.set_keep_above(True)
		self.window.show()

	def selection_made(self, data=None):
		"""entry clicked so we enable the remove button"""
		treesel = self.treeview.get_selection()
		sel = treesel.get_selected()
		if sel[1] != None:
			self.button_remove.set_sensitive(True)

	def cell_edited(self, cell, row, new_text, data, column):
		"""update entry with edited value"""
		data[row][column] = new_text
		return

	def button_add_clicked(self, data):
		"""add entry to list and focus cursor"""
		sel = data.append(['', '', ''])
		pos = data.get_path(sel)
		self.treeview.set_cursor(pos, self.urlcolumn, True)

	def button_remove_clicked(self, data):
		"""remove selected entry from list"""
		treesel = self.treeview.get_selection()
		sel = treesel.get_selected()

		sq = SQLite()
		sq.open(app_database)

		feed_url = sel[0].get_value(sel[1], 2)
		sq.execute('delete from posts where feed_url=?', (feed_url,))

		img = sq.execute('select img from feeds where feed_url=?', (feed_url,))
		if os.path.exists(os.path.join(app_cache_dir, unicode(img[0]))):
			os.remove(os.path.join(app_cache_dir, unicode(img[0])))

		sq.execute('delete from feeds where feed_url=?', (feed_url,))
		sq.commit()
		sq.close()

		data.remove(sel[1])
		self.button_remove.set_sensitive(False)

	def timer_scale(self, widget):
		"""refreshtimer slider interaction"""
		value = widget.get_value();
		if int(value) == 1:
			self.refreshtimeset = int(value)*60
			self.scaletimerlabel.set_text(language_properties['update_feed_every_m'])
		else:
			self.refreshtimeset = int(value)*60
			self.scaletimerlabel.set_text(str(language_properties['update_feed_every'] % str(self.refreshtimeset/60)))

	def items_scale(self, widget):
		"""scaleitems slider interaction"""
		value = widget.get_value();
		if int(value) == 1:
			self.itemsperfeedset = int(value)
			self.scaleitemslabel.set_text(language_properties['menu_shows_one_item_per_feed'])
		else:
			self.itemsperfeedset = int(value)
			self.scaleitemslabel.set_text(str(language_properties['menu_shows'] % str(self.itemsperfeedset)))

	def autostart_toggle(self, widget):
		"""check toggle status"""
		if widget.get_active():
			self.autostartset = True
		else:
			self.autostartset = False

	def shownotifications_toggle(self, widget):
		"""check toggle status"""
		if widget.get_active():
			self.shownotificationsset = True
			self.check_shownotificationsupdate.set_sensitive(True)
		else:
			self.shownotificationsset = False
			self.check_shownotificationsupdate.set_sensitive(False)

	def shownotificationsupdate_toggle(self, widget):
		"""check toggle status"""
		if widget.get_active():
			self.shownotificationsupdateset = True
		else:
			self.shownotificationsupdateset = False

	def usesubmenus_toggle(self, widget):
		"""check toggle status"""
		if widget.get_active():
			self.usesubmenusset = True
		else:
			self.usesubmenusset = False

	def language_toggle(self, widget):
		"""check toggle status"""
		tree_iter = widget.get_active_iter()
		if tree_iter != None:
			model = widget.get_model()
			self.langaugeset = model[tree_iter][0]

	def feedstop_toggle(self, widget):
		"""check toggle status"""
		if widget.get_active():
			self.feedstopset = True
		else:
			self.feedstopset = False

	def unreadfeeds_toggle(self, widget):
		"""check toggle status"""
		if widget.get_active():
			self.unreadfeedsset = True
		else:
			self.unreadfeedsset = False

	def autostart_create(self):
		"""create autostart file"""
		global autostart
	 	content = "\n"+"[Desktop Entry]\n"+"Type=Application\n"+"Exec="+app_identifier+" --autostarted\n"+"X-GNOME-Autostart-enabled=true\n"+"Icon="+app_identifier+"\n"+"Name="+app_name+"\n"+"Comment="+app_comments
		if not os.path.exists(app_autostart_folder):
			os.makedirs(app_autostart_folder, 0700)
	 	f = open(app_autostart_file, 'w')
	 	f.write(content)
	 	f.close()
		autostart = True

 	def autostart_delete(self):
		"""remove autostart file"""
		global autostart
		if os.path.exists(app_autostart_file):
			os.remove(app_autostart_file)
		autostart = False

	def keypress(self, widget, data):
		"""keypress handler"""
		if data.keyval == gtk.keysyms.Escape:
			self.window.destroy()

	def cancel_dialog(self, widget, data=None):
		"""cancel dialog"""
		self.window.destroy()

	def save_dialog(self, widget, data):
		"""save list to config file and close config dialog"""
		global refreshtime
		global itemsperfeed
		global autostart
		global shownotifications
		global shownotificationsupdate
		global usesubmenus
		global sound
		global feedstop
		global unreadfeeds
		global language_properties

		refreshtime = self.refreshtimeset
		gconf['refreshtime'] = self.refreshtimeset
		itemsperfeed = self.itemsperfeedset
		gconf['itemsperfeed'] = self.itemsperfeedset
		shownotifications = self.shownotificationsset
		gconf['shownotifications'] = self.shownotificationsset
		shownotificationsupdate = self.shownotificationsupdateset
		gconf['shownotificationsupdate'] = self.shownotificationsupdateset
		usesubmenus = self.usesubmenusset
		gconf['usesubmenus'] = self.usesubmenusset
		feedstop = self.feedstopset
		gconf['feedstop'] = self.feedstopset
		unreadfeeds = self.unreadfeedsset
		gconf['unreadfeeds'] = self.unreadfeedsset
		sound = self._textbox.get_text()
		gconf['sound'] = self._textbox.get_text()
		autostart = self.autostartset
		if autostart == True:
			self.autostart_create()
		else:
			self.autostart_delete()

		if not self.langaugeset == '':
			shutil.copyfile(os.path.join(app_language_dir, self.langaugeset), app_language_file)
			language_properties = ConfigObj(app_language_file)

		sq = SQLite()
		sq.open(app_database)

		for row in data:
			if row[2] == '' and row[0] == '':
				sq.execute('insert into feeds (feed_url) values (?)', (unicode(row[1]),))
			elif row[2] == '' and row[0] != '':
				sq.execute('insert into feeds (feed_url, title) values (?, ?)', (unicode(row[1]), unicode(row[0])))
			elif row[2] == row[1]:
				sq.execute('update feeds set title=? where feed_url=?', (unicode(row[0]), unicode(row[2])))
			else:
				sq.execute('update posts set feed_url=? where feed_url=?', (unicode(row[1]), unicode(row[2])))
				sq.execute('update feeds set title=?, feed_url=? where feed_url=?', (unicode(row[0]), unicode(row[1]), unicode(row[2])))

		sq.commit()
		sq.close()

		self.window.destroy()
		indicator.update_feeds(None, True, True)



##################################################
###############    AppIndicator    ###############
##################################################
class AppIndicator:
	def __init__(self):
		global refreshtime
		global stoptimer
		global itemsperfeed
		global autostart
		global shownotifications
		global shownotificationsupdate
		global usesubmenus
		global feedstop
		global unreadfeeds
		global sound

		if gconf['refreshtime'] is not None:
			refreshtime = gconf['refreshtime'];
		else:
			gconf['refreshtime'] = refreshtime;

		if gconf['itemsperfeed'] is not None:
			itemsperfeed = gconf['itemsperfeed'];
		else:
			gconf['itemsperfeed'] = itemsperfeed;

		if gconf['stoptimer'] is not None:
			stoptimer = gconf['stoptimer'];
		else:
			gconf['stoptimer'] = stoptimer;

		if gconf['shownotifications'] is not None:
			shownotifications = gconf['shownotifications'];
		else:
			gconf['shownotifications'] = shownotifications;

		if gconf['shownotificationsupdate'] is not None:
			shownotificationsupdate = gconf['shownotificationsupdate'];
		else:
			gconf['shownotificationsupdate'] = shownotificationsupdate;

		if gconf['usesubmenus'] is not None:
			usesubmenus = gconf['usesubmenus'];
		else:
			gconf['usesubmenus'] = usesubmenus;

		if gconf['feedstop'] is not None:
			feedstop = gconf['feedstop'];
		else:
			gconf['feedstop'] = feedstop;

		if gconf['unreadfeeds'] is not None:
			unreadfeeds = gconf['unreadfeeds'];
		else:
			gconf['unreadfeeds'] = unreadfeeds;

		if gconf['sound'] is not None:
			sound = gconf['sound'];
		else:
			gconf['sound'] = sound;

		if os.path.exists(app_autostart_file):
			autostart = True

		if not os.path.exists(app_database):
			sq = SQLite()
			sq.open(app_database)
			sq.execute('CREATE TABLE feeds (feed_url TEXT PRIMARY KEY, url TEXT, title TEXT, img TEXT)')
			sq.execute('CREATE TABLE posts (id TEXT PRIMARY KEY, post_url TEXT, title TEXT, read BOOLEAN DEFAULT false, feed_url TEXT NOT NULL, FOREIGN KEY(feed_url) REFERENCES feeds(feed_url))')

			app_config_file = os.path.join(app_config_dir, 'feeds.cfg')
			app_cache_file = os.path.join(app_cache_dir, 'feeds.dat')

			if os.path.exists(app_config_file):
				rssf = open(app_config_file)
				for line in rssf:
					line = string.replace(line, '\n', '')
					sq.execute('insert into feeds (feed_url) values (?)', (unicode(line),))

				rssf.close()
				os.remove(app_config_file)

			if os.path.exists(app_cache_file):
				os.remove(app_cache_file)

			sq.commit()
			sq.close()
		else:
			sq = SQLite()
			sq.open(app_database)

			posts = sq.execute('select id from posts')
			if posts == None:
				sq.execute('DROP TABLE posts')
				sq.execute('CREATE TABLE posts (id TEXT PRIMARY KEY, post_url TEXT, title TEXT, read BOOLEAN DEFAULT false, feed_url TEXT NOT NULL, FOREIGN KEY(feed_url) REFERENCES feeds(feed_url))')

			sq.commit()
			sq.close()

		self.ind = appindicator.Indicator(app_name, app_identifier, appindicator.CATEGORY_APPLICATION_STATUS)
		self.ind.set_status(appindicator.STATUS_ACTIVE) #STATUS_PASSIVE = hidden, STATUS_ACTIVE = visible, STATUS_ATTENTION = want the users attention
		self.ind.set_attention_icon(app_indicator_icon_attention)
		self.ind.set_icon(app_indicator_icon)

		self.menu = gtk.Menu()
		self.update_feeds(None, True, True)

	def set_status(self, status):
		"""turns the appindicator to attention and back to normal"""
		if status:
			self.ind.set_status(appindicator.STATUS_ATTENTION)
		else:
			self.ind.set_status(appindicator.STATUS_ACTIVE)

	def send_notification(self, title, message, image):
		"""send feed updates to notify-osd"""
		if not title == None:
			pynotify.init(title)
		if image == None:
			image = 'file://' + app_icon
		n = pynotify.Notification((title if not title == '' else ''), message, image)
		n.set_hint_string('x-canonical-append','')
		n.show()

	def menuitem_response_website(self, data, url):
		"""open the feed's website url"""
		webbrowser.open(url)

	def menuitem_response(self, data, post_id, url):
		"""open the website page url"""
		webbrowser.open(url)

		sq = SQLite()
		sq.open(app_database)
		sq.execute('update posts set read =\'true\' where id =? ', (post_id,))
		sq.commit()
		sq.close()

		sleep(0.5)
		self.render_menu()

	def updates_toggle(self, data):
		"""toggle updating"""
		global stoptimer
		if stoptimer == True:
			stoptimer = False
			gconf['stoptimer'] = False
			if shownotifications:
				self.send_notification(app_name + ' - ' + language_properties['started'], str(language_properties['feed_update_time_notification'] % str(refreshtime/60)), app_logo)
			self.update_feeds(None, True, True)
		else:
			stoptimer = True
			gconf['stoptimer'] = True
			if shownotifications:
				self.send_notification(app_name + ' - ' + language_properties['stopped'], language_properties['feed_update_stop_notification'], app_logo)

	def render_menu_empty(self, data):
		"""populate an empty menu"""
		for child in self.menu.get_children():
			child.destroy()
		menu_loading = gtk.MenuItem(language_properties['loading'])
		self.menu.append(menu_loading)
		menu_loading.set_sensitive(False)
		self.menu.show_all()
		self.ind.set_menu(self.menu)
		self.set_status(False)

	def render_menu(self):
		"""populate the menu"""
		global stoptimer
		global feedstop
		global unreadfeeds

		for child in self.menu.get_children():
			child.destroy()

		sq = SQLite()
		sq.open(app_database)

		if unreadfeeds:
			feeds = sq.execute('select title, url, feed_url, (select count(*) from posts where posts.feed_url=feeds.feed_url and read=\'false\') as c from feeds order by c desc, upper(title)')
		else:
			feeds = sq.execute('select title, url, feed_url, (select count(*) from posts where posts.feed_url=feeds.feed_url and read=\'false\') as c from feeds where c > 0 order by c desc, upper(title)')
		empty = len(feeds) > 0
		hasfeeds = len(sq.execute('select count(*) from feeds')) > 0

		if feedstop == False:
			self.render_menu_conf(hasfeeds)
			if hasfeeds:
				self.menu.append(gtk.SeparatorMenuItem())

		if not empty:
			no_unread = gtk.MenuItem('No unread feeds.')
			self.menu.append(no_unread)
			no_unread.set_sensitive(False)



		for feed in feeds:
			posts = sq.execute(str('select id, title, post_url from posts where feed_url=? and read == \'false\' order by id limit %i' % itemsperfeed), (feed[2],))
			if usesubmenus == True:
				menu_header = self.create_menu_header(('(' + unicode(feed[3]) + ') ' if not feed[3] == 0 else '') + unicode(feed[0]), '')
				menu_row = self.create_menu_header(language_properties['open_website'], feed[1])
				submenu = gtk.Menu()
				submenu.append(menu_row)
				submenu_open_unread = gtk.MenuItem(language_properties['open_all_unread'])
				submenu_open_unread.connect('activate', self.open_unread, feed[2])
				submenu.append(submenu_open_unread)

				if int(feed[3]) > itemsperfeed:
					submenu_open2 = gtk.MenuItem(language_properties['open_displayed'])
					submenu_open2.connect('activate', self.feed_open_displayed, feed[2])
					submenu.append(submenu_open2)

				submenu_read = gtk.MenuItem(language_properties['mark_as_read'])
				submenu_read.connect('activate', self.feed_read, feed[2])
				submenu.append(submenu_read)

				if int(feed[3]) > itemsperfeed:
					submenu_read2 = gtk.MenuItem(language_properties['mark_displayed_as_read'])
					submenu_read2.connect('activate', self.feed_read_displayed, feed[2])
					submenu.append(submenu_read2)

				submenu_read = gtk.MenuItem(language_properties['mark_as_unread'])
				submenu_read.connect('activate', self.feed_unread, feed[2])
				submenu.append(submenu_read)

				if len(posts) > 0:
					posts.reverse()
					submenu.append(gtk.SeparatorMenuItem())
				
					for post in posts:
						menu_row = self.create_menu_item(post[1], post[0], post[2])
						submenu.append(menu_row)

				menu_header.set_submenu(submenu)
				self.menu.append(menu_header)
			else:
				menu_header = self.create_menu_header(('(' + unicode(feed[3]) + ') ' if not feed[3] == 0 else '') + unicode(feed[0]), feed[1])
				self.menu.append(menu_header)

				if len(posts) > 0:
					posts.reverse()

					for post in posts:
						menu_row = self.create_menu_item(post[1], post[0], post[2])
						self.menu.append(menu_row)

		hasunread = sq.contains('select * from posts where read=\'false\'')

		sq.close()

		if feedstop == True:
			self.render_menu_conf(hasfeeds)

		self.menu.show_all()
		self.ind.set_menu(self.menu)

		if hasunread:
			self.set_status(True)
		else:
			self.set_status(False)

	def render_menu_conf(self, hasfeeds):
		global stoptimer
		global feedstop

		if hasfeeds:
			if feedstop == True:
				self.menu.append(gtk.SeparatorMenuItem())

			menu_open_unread = gtk.MenuItem(language_properties['open_all_unread'])
			menu_open_unread.connect('activate', self.open_unread, '')
			self.menu.append(menu_open_unread)
			menu_read = gtk.MenuItem(language_properties['mark_all_as_read'])
			menu_read.connect('activate', self.feed_read, '')
			self.menu.append(menu_read)
			menu_unread = gtk.MenuItem(language_properties['mark_all_as_unread'])
			menu_unread.connect('activate', self.feed_unread, '')
			self.menu.append(menu_unread)
			menu_update = gtk.MenuItem(language_properties['reload_all_feeds'])
			menu_update.connect('activate', self.update_feeds, True, False)
			self.menu.append(menu_update)
			self.menu.append(gtk.SeparatorMenuItem())
			if refreshtime/60 == 1:
				menu_updatecheck = gtk.CheckMenuItem(language_properties['update_feed_every_m'])
			else:
				menu_updatecheck = gtk.CheckMenuItem(str(language_properties['update_feed_every'] % str(refreshtime/60)))
			if stoptimer == True:
				menu_updatecheck.set_active(False)
			else:
				menu_updatecheck.set_active(True)
			menu_updatecheck.connect('toggled', self.updates_toggle)
			self.menu.append(menu_updatecheck)
		else:
			menu_notice = gtk.MenuItem(language_properties['no_feeds_defined'])
			self.menu.append(menu_notice)
			menu_notice.set_sensitive(False)
			self.menu.append(gtk.SeparatorMenuItem())

		menu_add = gtk.MenuItem(language_properties['add_feed'])
		self.menu.append(menu_add)
		menu_add.connect('activate', AddFeedDialog)
		menu_configure = gtk.MenuItem(str(language_properties['configure'] % app_name))
		self.menu.append(menu_configure)
		menu_configure.connect('activate', ConfigureDialog)
		menu_quit = gtk.MenuItem(language_properties['quit'])
		self.menu.append(menu_quit)
		menu_quit.connect('activate', Exit)

	def create_menu_header(self, title, url):
		"""create the menu heading for each feed"""
		menu_row = gtk.MenuItem(title)
		if url != '':
			menu_row.connect('activate', self.menuitem_response_website, url)
		return menu_row

	def create_menu_item(self, title, post_id, url):
		"""create the menu entries for each feed"""
		if usesubmenus == True:
			menu_row = gtk.MenuItem(title)
		else:
			menu_row = gtk.MenuItem("        " + title)
		menu_row.connect('activate', self.menuitem_response, post_id, url)
		return menu_row

	def open_unread(self, data, url):
		"""opens all unread post of the given feed"""
		sq = SQLite()
		sq.open(app_database)

		if not url == '':
			posts = sq.execute('select post_url from posts where feed_url=? and read=\'false\'', (url,))
			for post in posts:
				webbrowser.open(post[0])
				sleep(0.6)

			sq.execute('update posts set read=\'true\' where feed_url=?', (url,))
		else:
			feeds = sq.execute('select feed_url from feeds')

			for feed in feeds:
				posts = sq.execute('select post_url from posts where feed_url=? and read=\'false\'', feed)
				for post in posts:
					webbrowser.open(post[0])
					sleep(0.6)

				sq.execute('update posts set read=\'true\' where feed_url=?', feed)

		sq.commit()
		sq.close()

		sleep(0.5)
		self.render_menu()

	def feed_open_displayed(self, data, url):
		"""opens all unread post of the given feed"""
		sq = SQLite()
		sq.open(app_database)

		posts = sq.execute(str('select post_url from posts where feed_url=? and read=\'false\' order by id limit %i' % itemsperfeed), (url,))
		for post in posts:
			webbrowser.open(post[0])
			sleep(0.6)

		sq.execute(str('update posts set read=\'true\' where feed_url=? order by id limit %i' % itemsperfeed), (url,))
		sq.commit()
		sq.close()

		sleep(0.5)
		self.render_menu()

	def feed_read(self, data, url):
		"""marks all posts of all feeds or a specific feed as read"""
		sq = SQLite()
		sq.open(app_database)
		if url == '':
			sq.execute('update posts set read=\'true\'')
		else:
			sq.execute('update posts set read=\'true\' where feed_url=?', (url,))
		sq.commit()
		sq.close()

		sleep(0.5)
		self.render_menu()

	def feed_read_displayed(self, data, url):
		"""marks displayed posts of given feed as read"""
		sq = SQLite()
		sq.open(app_database)
		sq.execute(str('update posts set read=\'true\' where feed_url=? and id in (select id from posts where feed_url=? and read == \'false\' order by id limit %i)' % itemsperfeed), (url,url))
		sq.commit()
		sq.close()

		sleep(0.5)
		self.render_menu()

	def feed_unread(self, data, url):
		"""marks all posts of all feeds or a specific feed as read"""
		sq = SQLite()
		sq.open(app_database)
		if url == '':
			sq.execute('update posts set read=\'false\'')
		else:
			sq.execute('update posts set read=\'false\' where feed_url=?', (url,))
		sq.commit()
		sq.close()

		sleep(0.5)
		self.render_menu()

	def update_feeds(self, data=None, timeroverride=False, starttimer=False):
		"""start updating feeds"""
		global stoptimer

		if stoptimer == True and timeroverride == False:
			return False

		if starttimer:
			glib.timeout_add_seconds(refreshtime, self.update_feeds, True)

		if shownotifications and shownotificationsupdate:
			self.send_notification(app_name, language_properties['feed_update_start_notification'], app_logo)

		self.render_menu_empty(None)
		FeedThread().start()
		return True

	def finnished_update(self):
		"""renders menu and shows notification after FeadThread has ended"""
		self.render_menu()

		if shownotifications:
			sq = SQLite()
			sq.open(app_database)

			feeds = sq.execute('select title, img, feed_url from feeds where feed_url in (select feed_url from posts where read = \'false\' group by feed_url limit 50) order by (select count(feed_url) as c from posts where read = \'false\' group by feed_url order by c desc limit 49), upper(title)') #notification stack is limit to 50

			if len(feeds) > 0:
				if not sound == '':
					os.system(sound)

				for feed in feeds:
					count = 0
					notifymsg = ''
					posts = sq.execute('select title from posts where read = \'false\' and feed_url=? limit 3', (feed[2],))

					if len(posts) > 0:
						for post in posts:
							notifymsg += '\n' + unicode(post[0])

						if feed[1] == None:
							self.send_notification(feed[0], notifymsg, None)
						else:
							self.send_notification(feed[0], notifymsg, os.path.join(app_cache_dir, feed[1]))
			else:
				if shownotificationsupdate:
					self.send_notification(app_name, language_properties['feed_update_finish_notification'], app_logo)

			sq.close()



##################################################
def main():
	gtk.gdk.threads_init()
	gtk.mainloop()
	return 0

if __name__ == "__main__":
	"""delay to make sure config files are accessible on autostart"""
	cmdline = sys.argv
	if len(cmdline) > 1:
		if cmdline[1] == '--autostarted':
			time.sleep(5)
	if gc.isenabled() == False:
		gc.enable()

	if not os.path.exists(app_language_file):
		shutil.copyfile(os.path.join(app_language_dir, 'english.properties'), app_language_file)
	language_properties = ConfigObj(app_language_file)

	gconf = GConf(app_identifier)
	indicator = AppIndicator()
	main()