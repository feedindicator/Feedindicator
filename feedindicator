#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#		feedindicator
#       Copyright (C) 2010-2011 Dave Gardner <eunbolt@gmail.com> & Michael Judge <email@clickopen.co.uk>
#
#		This program is free software: you can redistribute it and/or modify
#		it under the terms of the GNU General Public License as published by
#		the Free Software Foundation, either version 3 of the License, or
#		(at your option) any later version.
#
#		This program is distributed in the hope that it will be useful,
#		but WITHOUT ANY WARRANTY; without even the implied warranty of
#		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#		GNU General Public License for more details.
#
#		You should have received a copy of the GNU General Public License
#		along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# [SNIPPET_NAME: Parse an RSS feed]
# [SNIPPET_CATEGORIES: feedparser]  
# [SNIPPET_DESCRIPTION: Parse and iterate over the items in an RSS feed]
# [SNIPPET_AUTHOR: Tim Voet <tim.voet@gmail.com>]
# [SNIPPET_DOCS: http://www.feedparser.org/docs/introduction.html]
# [SNIPPET_LICENSE: GPL]

# need python-feedparser and app-indicator(should come with ubuntu 10.04 and above)

import pygtk
pygtk.require('2.0')
import glib
import gtk
import appindicator
import feedparser
import gc
import hashlib
import os
import pynotify
import string
import sys
import urllib
import webbrowser
import gconf
import time
import gobject
import sqlite3 as lite
from threading import Thread
from time import sleep
from gconf import VALUE_BOOL, VALUE_INT, VALUE_STRING, VALUE_FLOAT
from types import BooleanType, StringType, IntType, FloatType

# clear out the html element list so all are removed
feedparser._HTMLSanitizer.acceptable_elements = []

# common name used for file paths, gconf and indicator identifier
app_identifier = 'feedindicator'

# indicator icon names
app_indicator_icon = 'indicator-feedindicator'
app_indicator_icon_attention = 'indicator-feedindicator-attention'

# XDG config
xdg_config_dir = glib.get_user_config_dir()
app_config_dir = os.path.join(xdg_config_dir, app_identifier)
#app_config_file = os.path.join(app_config_dir, 'feeds.test.cfg')

# XDG cache
xdg_cache_dir = glib.get_user_cache_dir()
app_cache_dir = os.path.join(xdg_cache_dir, app_identifier)
#app_cache_file = os.path.join(app_cache_dir, 'feeds.test.dat')

# /usr/share/
app_share_dir = '/usr/share/'+app_identifier+'/'
app_icon = os.path.join(app_share_dir, 'feedindicator-icon.png')
app_logo = os.path.join(app_share_dir, 'feedindicator-logo.png')

# database
app_database = os.path.join(app_config_dir, 'feedindicator.db')

# autostart file
app_autostart_folder = os.path.join(xdg_config_dir, 'autostart')
app_autostart_file = os.path.join(app_autostart_folder, app_identifier+'.desktop')

# general app info mostly used in about dialog
app_name = 'Feedindicator'
app_version = '1.03'
app_comments = 'RSS feed updates in the indicator area'
app_copyright = 'Copyright (C) 2010-2011 Dave Gardner & Michael Judge'
app_website = 'http://code.google.com/p/feedindicator/'
app_license = (('This program is free software: you can redistribute it and/or modify\n'+
'it under the terms of the GNU General Public License as published by\n'+
'the Free Software Foundation, either version 3 of the License, or\n'+
'(at your option) any later version.\n'+
'\n'+
'This program is distributed in the hope that it will be useful,\n'+
'but WITHOUT ANY WARRANTY; without even the implied warranty of\n'+
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n'+
'GNU General Public License for more details.\n'+
'\n'+
'You should have received a copy of the GNU General Public License\n'+
'along with this program.  If not, see <http://www.gnu.org/licenses/>.'))
app_authors = ['Dave Gardner <eunbolt@gmail.com>','Michael Judge <email@clickopen.co.uk>']
app_documenters = ['Dave Gardner <eunbolt@gmail.com>','Michael Judge <email@clickopen.co.uk>']

# default autostart status
autostart = False

# default feed refresh time (minutes*seconds)
refreshtime = 30*60

# default stop the timer from running?
stoptimer = False

# default menu items to show per feed
itemsperfeed = 5

# default put feed items in submenus
usesubmenus = False

# default show notification popups
shownotifications = True



##################################################
###############       SQLite       ###############
##################################################
class SQLite:
	def get_con():
		return self._con

	con = property(get_con)

	def __init__(self):
		self._con = None

	def open(self, path):
		"""opens a new connection"""
		try:
			self._con = lite.connect(path)
		except lite.Error, e:
			print e

	def close(self):
		"""closes the current connection"""
		if self._con:
			try:
				self._con.close()
			except lite.Error, e:
				print e

	def execute(self, query, data=()):
		"""executes the given query and returns the results"""
		if self._con:
			try:
				cur = self._con.cursor()
				if data == ():
					cur.execute(query)
				else:
					cur.execute(query, data)
				rows = cur.fetchall()
				return rows
			except lite.Error, e:
				print e

		return None

	def executemany(self, query, data):
		"""executes the given query with executemany()"""
		if self._con:
			try:
				cur = self._con.cursor()
				cur.executemany(query, data)
			except lite.Error, e:
				print e

	def commit(self):
		"""commits changes to the database"""
		if self._con:
			try:
				self._con.commit()
			except lite.Error, e:
				self._con.rollback()
				print e

	def contains(self, query, data=()):
		"""checks wheter the given query has results or not"""
		if self._con:
			try:
				cur = self._con.cursor()
				if data == ():
					cur.execute(query)
				else:
					cur.execute(query, data)
				rows = cur.fetchone()

				if rows:
					return True;
				else:
					return False;
			except lite.Error, e:
				print e



##################################################
###############        Exit        ###############
##################################################
class Exit:
	def __init__(self, widget):
		sys.exit()



##################################################
###############        GConf       ###############
##################################################
class GConf:
	def __init__ (self, appname, allowed={}):
		self._domain = '/apps/%s/' % appname
		self._allowed = allowed
		self._gconf_client = gconf.client_get_default ()

	def __getitem__ (self, attr):
		return self.get_value (attr)

	def __setitem__ (self, key, val):
		allowed = self._allowed
		if allowed.has_key(key):
			if not key in allowed[key]:
				good = ', '.join (allowed[key])
				return False
		self.set_value (key, val)

	def _get_type (self, key):
		KeyType = type (key)
		if KeyType == BooleanType:
			return 'bool'
		elif KeyType == StringType:
			return 'string'
		elif KeyType == IntType:
			return 'int'
		elif KeyType == FloatType:
			return 'float'
		else:
			return None

	# Public functions
	def set_allowed (self, allowed):
		self._allowed = allowed

	def set_domain (self, domain):
		self._domain = domain

	def get_domain (self):
		return self._domain

	def get_gconf_client (self):
		return self._gconf_client

	def get_value (self, key):
		"""returns the value of key 'key' """
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		value = self._gconf_client.get(self._domain + key)
		if value is not None:
			ValueType = value.type
			if ValueType == VALUE_BOOL:
				return value.get_bool()
			elif ValueType == VALUE_INT:
				return value.get_int()
			elif ValueType == VALUE_STRING:
				return value.get_string()
			elif ValueType == VALUE_FLOAT:
				return value.get_float()
			else:
				return None
		else:
			return None

	def set_value (self, key, value):
		"""sets the value of key 'key' to 'value' """
		value_type = self._get_type(value)
		if value_type is not None:
			if '/' in key:
				raise 'GConfError', 'key must not contain /'
			func = getattr (self._gconf_client, 'set_' + value_type)
			apply(func, (self._domain + key, value))

	def get_string (self, key):
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		return self._gconf_client.get_string(self._domain + key)

	def set_string (self, key, value):
		if type (value) != StringType:
			raise 'GConfError', 'value must be a string'
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		self._gconf_client.set_string(self._domain + key, value)

	def get_bool (self, key):
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		return self._gconf_client.get_bool(self._domain + key)

	def set_bool (self, key, value):
		if type (value) != IntType and (key != 0 or key != 1):
			raise 'GConfError', 'value must be a boolean'
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		self._gconf_client.set_bool(self._domain + key, value)

	def get_int (self, key):
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		return self._gconf_client.get_int(self._domain + key)

	def set_int (self, key, value):
		if type (value) != IntType:
			raise 'GConfError', 'value must be an int'
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		self._gconf_client.set_int(self._domain + key, value)

	def get_float (self, key):
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		return self._gconf_client.get_float(self._domain + key)

	def set_float (self, key, value):
		if type (value) != FloatType:
			raise 'GConfError', 'value must be a float'
		if '/' in key:
			raise 'GConfError', 'key must not contain /'
		self._gconf_client.set_float(self._domain + key, value)



##################################################
###############     FeedThread     ###############
##################################################
class FeedThread(Thread):
	def run(self):
		"""updates all feeds in the database und updates the infos"""
		sq = SQLite()
		sq.open(app_database)

		feeds = sq.execute('select feed_url, title, url, img from feeds')
		if len(feeds) > 0:
			for feed in feeds:
				feedinfo = self.parse_feed(feed[0])

				if feedinfo['success']:
					if feed[1] == None:
						sq.execute('update feeds set title=? where feed_url=?', (unicode(feedinfo['feeddata']['title']), feed[0]))
					if not feed[2] == unicode(feedinfo['feeddata']['link']):
						sq.execute('update feeds set url=? where feed_url=?', (unicode(feedinfo['feeddata']['link']), feed[0]))
					if not unicode(feedinfo['feeddata']['img']) == 'None':
						sq.execute('update feeds set img=? where feed_url=?', (unicode(feedinfo['feeddata']['img']), feed[0]))

					items = ()
					for postdata in feedinfo['postdata']:
						if not sq.contains('select * from posts where post_url=?', (postdata['link'],)):
							items = items + ((unicode(postdata['link']), unicode(postdata['title']), unicode(feed[0])), )

					if not items == ():
						sq.executemany('insert into posts (post_url, title, feed_url) values (?,?,?)', items)

		sq.commit()
		sq.close()

		gobject.idle_add(indicator.finnished_update)

	def parse_feed(self, url):
		"""parses a feed and returns the infos"""
		feedinfo = {}
		feedinfo['feeddata'] = {}
		feedinfo['postdata'] = []
		feedinfo['success'] = False
		try:
			rssfeed = feedparser.parse(url)
			postdata = []
			for val in rssfeed.entries:
				val.title = string.replace(val.title, '\n', '')
				if len(val.title) > 72:
					substr = val.title[:72]
					substr = substr.rpartition(' ')
					if substr[0] != '':
						val.title = substr[0] + '...'
				v = {'title': val.title, 'link': val.link}
				postdata.append(v)
			feedinfo['postdata'] = postdata
			feedimg = None
			webimg = None
			if 'image' in rssfeed.feed:
				webimg = rssfeed.feed.image.href
			elif 'logo' in rssfeed.feed:
				webimg = rssfeed.feed.logo
			elif 'icon' in rssfeed.feed:
				webimg = rssfeed.feed.icon
			if webimg != None:
				ext = webimg.rsplit('.', 1)
				md5hash = hashlib.md5(str(url)).hexdigest()
				localimg = os.path.join(app_cache_dir, md5hash + '.' + ext[1])
				urllib.urlretrieve(webimg, localimg)
				feedimg = md5hash + '.' + ext[1]
			feedinfo['feeddata'] = {'title': rssfeed.feed.title, 'link': rssfeed.feed.link, 'img': feedimg}
			feedinfo['success'] = True
		except:
			pass

		return feedinfo



##################################################
###############   AddFeedDialog    ###############
##################################################
class AddFeedDialog:
	def __init__(self, widget):
		self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
		self.window.set_size_request(450, 120)
		self.window.set_position(gtk.WIN_POS_CENTER)
		self.window.set_title('Add feed ' + app_name)
		self.window.connect('delete_event', self.cancel_dialog)
		self.window.connect('key-press-event', self.keypress)

		vbox = gtk.VBox(False, 10)
		vbox.set_border_width(10)
		self.window.add(vbox)
		vbox.show()

		hboxl = gtk.HBox(False, 0)
		vbox.pack_start(hboxl, False, True, 0)
		hboxl.show()

		label = gtk.Label('Add a new feed url to show in the menu.')
		label.set_justify(gtk.JUSTIFY_LEFT)
		label.set_line_wrap(True)
		hboxl.pack_start(label, False, True, 0)
		label.show()

		hbox2 = gtk.HBox(False, 0)
		vbox.pack_start(hbox2, False, True, 0)
		hbox2.show()

		self._textbox = gtk.Entry()
		hbox2.pack_start(self._textbox, True, True, 0)
		self._textbox.connect("activate", self.save_dialog)
		self._textbox.show()

		hbox3 = gtk.HBox(True, 0)
		vbox.pack_end(hbox3, False, True, 5)
		hbox3.show()

		button_cancel = gtk.Button('Cancel')
		hbox3.pack_start(button_cancel, True, True, 0)
		button_cancel.connect_object('clicked', self.cancel_dialog, button_cancel)
		button_cancel.show()
		button_save = gtk.Button('Add')
		hbox3.pack_start(button_save, True, True, 0)
		button_save.connect_object('clicked', self.save_dialog, None)
		button_save.show()

		self.window.set_keep_above(True)
		self.window.show()

	def cancel_dialog(self, widget, data=None):
		"""cancel dialog"""
		self.window.destroy()

	def save_dialog(self, data):
		"""save feed to config file and close add feed dialog"""
		self.window.set_modal(True)
		sq = SQLite()
		sq.open(app_database)
		sq.execute('insert into feeds (feed_url) values (?)', (unicode(self._textbox.get_text()),))
		sq.commit()
		sq.close()
		self.window.destroy()

		indicator.update_feeds(None, True, True)

	def keypress(self, widget, data):
		"""keypress handler"""
		if data.keyval == gtk.keysyms.Escape:
			self.window.destroy()
		elif data.keyval == gtk.keysyms.Return:
			self.save_dialog(None)



##################################################
###############     AboutDialog    ###############
##################################################
class AboutDialog:
	def __init__(self, widget):
		about = gtk.AboutDialog()
		about.set_logo(gtk.gdk.pixbuf_new_from_file(app_logo))
		about.set_name(app_name)
		about.set_program_name(app_name)
		about.set_version(app_version)
		about.set_comments(app_comments)
		about.set_copyright(app_copyright)
		about.set_license(app_license)
		about.set_website(app_website)
		about.set_website_label(app_website)
		about.set_authors(app_authors)
		about.set_documenters(app_documenters)
		about.run()
		about.destroy()



##################################################
###############  ConfigureDialog   ###############
##################################################
class ConfigureDialog:
	def __init__(self, widget):
		self.refreshtimeset = refreshtime
		self.itemsperfeedset = itemsperfeed
		self.autostartset = autostart
		self.shownotificationsset = shownotifications
		self.usesubmenusset = usesubmenus

		self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
		self.window.set_size_request(650, 450)
		self.window.set_position(gtk.WIN_POS_CENTER)
		self.window.set_title('Configure ' + app_name)
		self.window.connect('delete_event',self.cancel_dialog)
		self.window.connect('key-press-event', self.keypress)

		vbox = gtk.VBox(False, 10)
		vbox.set_border_width(10)
		self.window.add(vbox)
		vbox.show()

		hboxl = gtk.HBox(False, 0)
		vbox.pack_start(hboxl, False, True, 0)
		hboxl.show()

		label = gtk.Label('Configure feed urls to show in the menu.')
		label.set_justify(gtk.JUSTIFY_LEFT)
		label.set_line_wrap(True)
		hboxl.pack_start(label, False, True, 0)
		label.show()

		scrolled_window = gtk.ScrolledWindow()
		scrolled_window.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_ALWAYS)
		scrolled_window.set_shadow_type(gtk.SHADOW_IN)
		vbox.pack_start(scrolled_window, True, True, 0)
		scrolled_window.show()

		liststore = gtk.ListStore(str, str, str)

		sq = SQLite()
		sq.open(app_database)

		feeds = sq.execute('select feed_url, title from feeds order by title')
		for feed in feeds:
			liststore.append([unicode(feed[0]), unicode(feed[1]), unicode(feed[0])])

		sq.close()

		self.treeview = gtk.TreeView(liststore)

		self.urlcolumn = gtk.TreeViewColumn('URL')
		self.treeview.append_column(self.urlcolumn)
		textrenderer = gtk.CellRendererText()
		self.urlcolumn.pack_start(textrenderer, True)
		self.urlcolumn.add_attribute(textrenderer, 'text', 0)
		textrenderer.set_property('editable', True)
		textrenderer.connect('edited', self.cell_edited, liststore, 0)

		textrenderer = gtk.CellRendererText()
		self.titlecolumn = gtk.TreeViewColumn('Title')
		self.treeview.append_column(self.titlecolumn)
		self.titlecolumn.pack_start(textrenderer, True)
		self.titlecolumn.add_attribute(textrenderer, 'text', 1)
		textrenderer.set_property('editable', True)
		textrenderer.connect('edited', self.cell_edited, liststore, 1)

		self.treeview.set_headers_clickable(False)
		self.treeview.set_reorderable(True)
		self.treeview.connect('cursor-changed', self.selection_made)
		scrolled_window.add(self.treeview)
		self.treeview.show()

		hbox1 = gtk.HBox(True, 0)
		vbox.pack_start(hbox1, False, True, 0)
		hbox1.show()

		self.button_change = gtk.Button('Add New')
		hbox1.pack_start(self.button_change, True, True, 0)
		self.button_change.connect_object('clicked', self.button_add_clicked, liststore)
		self.button_change.show()
		self.button_remove = gtk.Button('Remove')
		hbox1.pack_start(self.button_remove, True, True, 0)
		self.button_remove.connect_object('clicked', self.button_remove_clicked, liststore)
		self.button_remove.set_sensitive(False)
		self.button_remove.show()

		hbox2sl = gtk.HBox(False, 0)
		vbox.pack_start(hbox2sl, False, True, 0)
		hbox2sl.show()

		self.scaletimerlabel = gtk.Label('Update feeds every...')
		hbox2sl.pack_start(self.scaletimerlabel, False, False, 0)
		self.scaletimerlabel.show()

		hbox2s = gtk.HBox(False, 0)
		vbox.pack_start(hbox2s, False, True, 0)
		hbox2s.show()

		adjtimer = gtk.Adjustment(int(self.refreshtimeset/60), 1.0, 90.0, 1.0, 10.0, 0.0)
		adjtimer.connect('value_changed', self.timer_scale)
		scaletimer = gtk.HScale(adjtimer)
		scaletimer.set_draw_value(False)
		scaletimer.set_digits(0)
		hbox2s.pack_start(scaletimer, True, True, 0)
		self.timer_scale(adjtimer)
		scaletimer.show()

		hbox2il = gtk.HBox(False, 0)
		vbox.pack_start(hbox2il, False, True, 0)
		hbox2il.show()

		self.scaleitemslabel = gtk.Label('Items per feed...')
		hbox2il.pack_start(self.scaleitemslabel, False, False, 0)
		self.scaleitemslabel.show()

		hbox2i = gtk.HBox(False, 0)
		vbox.pack_start(hbox2i, False, True, 0)
		hbox2i.show()

		adjitems = gtk.Adjustment(int(self.itemsperfeedset), 1.0, 30.0, 1.0, 10.0, 0.0)
		adjitems.connect('value_changed', self.items_scale)
		scaleitems = gtk.HScale(adjitems)
		scaleitems.set_draw_value(False)
		scaleitems.set_digits(0)
		hbox2i.pack_start(scaleitems, True, True, 0)
		self.items_scale(adjitems)
		scaleitems.show()

		hbox2t = gtk.HBox(False, 0)
		vbox.pack_start(hbox2t, False, True, 0)
		hbox2t.show()

		check_autostart = gtk.CheckButton('Run at startup')
		hbox2t.pack_start(check_autostart, True, True, 0)
		if autostart == True:
			check_autostart.set_active(True)
		check_autostart.connect('toggled', self.autostart_toggle)
		check_autostart.show()

		check_shownotifications = gtk.CheckButton('Show notifications')
		hbox2t.pack_start(check_shownotifications, True, True, 0)
		if shownotifications == True:
			check_shownotifications.set_active(True)
		check_shownotifications.connect('toggled', self.shownotifications_toggle)
		check_shownotifications.show()

		check_usesubmenus = gtk.CheckButton('Submenu for each feed')
		hbox2t.pack_start(check_usesubmenus, True, True, 0)
		if usesubmenus == True:
			check_usesubmenus.set_active(True)
		check_usesubmenus.connect('toggled', self.usesubmenus_toggle)
		check_usesubmenus.show()

		hbox3 = gtk.HBox(True, 0)
		vbox.pack_end(hbox3, False, True, 5)
		hbox3.show()

		button_about = gtk.Button('About')
		hbox3.pack_start(button_about, True, True, 0)
		button_about.connect_object('clicked', AboutDialog, button_about)
		button_about.show()
		button_cancel = gtk.Button('Cancel')
		hbox3.pack_start(button_cancel, True, True, 0)
		button_cancel.connect_object('clicked', self.cancel_dialog, button_cancel)
		button_cancel.show()
		button_save = gtk.Button('Save')
		hbox3.pack_start(button_save, True, True, 0)
		button_save.connect_object('clicked', self.save_dialog, liststore)
		button_save.show()

		self.window.set_keep_above(True)
		self.window.show()

	def selection_made(self, data=None):
		"""entry clicked so we enable the remove button"""
		treesel = self.treeview.get_selection()
		sel = treesel.get_selected()
		if sel[1] != None:
			self.button_remove.set_sensitive(True)

	def cell_edited(self, cell, row, new_text, data, column):
		"""update entry with edited value"""
		data[row][column] = new_text
		return

	def button_add_clicked(self, data):
		"""add entry to list and focus cursor"""
		sel = data.append(['', '', ''])
		pos = data.get_path(sel)
		self.treeview.set_cursor(pos, self.urlcolumn, True)

	def button_remove_clicked(self, data):
		"""remove selected entry from list"""
		treesel = self.treeview.get_selection()
		sel = treesel.get_selected()

		sq = SQLite()
		sq.open(app_database)

		feed_url = sel[0].get_value(sel[1], 2)
		sq.execute('delete from posts where feed_url=?', (feed_url,))

		img = sq.execute('select img from feeds where feed_url=?', (feed_url,))
		if os.path.exists(os.path.join(app_cache_dir, unicode(img[0]))):
			os.remove(os.path.join(app_cache_dir, unicode(img[0])))

		sq.execute('delete from feeds where feed_url=?', (feed_url,))
		sq.commit()
		sq.close()

		data.remove(sel[1])
		self.button_remove.set_sensitive(False)

	def timer_scale(self, widget):
		"""refreshtimer slider interaction"""
		value = widget.get_value();
		if int(value) == 1:
			self.refreshtimeset = int(value)*60
			self.scaletimerlabel.set_text('Update feeds every minute')
		else:
			self.refreshtimeset = int(value)*60
			self.scaletimerlabel.set_text('Update feeds every ' + str(self.refreshtimeset/60) + ' minutes')

	def items_scale(self, widget):
		"""scaleitems slider interaction"""
		value = widget.get_value();
		if int(value) == 1:
			self.itemsperfeedset = int(value)
			self.scaleitemslabel.set_text('Menu shows 1 item per feed')
		else:
			self.itemsperfeedset = int(value)
			self.scaleitemslabel.set_text('Menu shows ' + str(self.itemsperfeedset) + ' items per feed')

	def autostart_toggle(self, widget):
		"""check toggle status"""
		if widget.get_active():
			self.autostartset = True
		else:
			self.autostartset = False

	def shownotifications_toggle(self, widget):
		"""check toggle status"""
		if widget.get_active():
			self.shownotificationsset = True
		else:
			self.shownotificationsset = False

	def usesubmenus_toggle(self, widget):
		"""check toggle status"""
		if widget.get_active():
			self.usesubmenusset = True
		else:
			self.usesubmenusset = False

	def autostart_create(self):
		"""create autostart file"""
		global autostart
	 	content = "\n"+"[Desktop Entry]\n"+"Type=Application\n"+"Exec="+app_identifier+" --autostarted\n"+"X-GNOME-Autostart-enabled=true\n"+"Icon="+app_identifier+"\n"+"Name="+app_name+"\n"+"Comment="+app_comments
		if not os.path.exists(app_autostart_folder):
			os.makedirs(app_autostart_folder, 0700)
	 	f = open(app_autostart_file, 'w')
	 	f.write(content)
	 	f.close()
		autostart = True

 	def autostart_delete(self):
		"""remove autostart file"""
		global autostart
		if os.path.exists(app_autostart_file):
			os.remove(app_autostart_file)
		autostart = False

	def keypress(self, widget, data):
		"""keypress handler"""
		if data.keyval == gtk.keysyms.Escape:
			self.window.destroy()

	def cancel_dialog(self, widget, data=None):
		"""cancel dialog"""
		self.window.destroy()

	def save_dialog(self, data):
		"""save list to config file and close config dialog"""
		global refreshtime
		global itemsperfeed
		global autostart
		global shownotifications
		global usesubmenus
		refreshtime = self.refreshtimeset
		gconf['refreshtime'] = self.refreshtimeset
		itemsperfeed = self.itemsperfeedset
		gconf['itemsperfeed'] = self.itemsperfeedset
		shownotifications = self.shownotificationsset
		gconf['shownotifications'] = self.shownotificationsset
		usesubmenus = self.usesubmenusset
		gconf['usesubmenus'] = self.usesubmenusset
		autostart = self.autostartset
		if autostart == True:
			self.autostart_create()
		else:
			self.autostart_delete()

		sq = SQLite()
		sq.open(app_database)

		for row in data:
			if row[2] == '' and row[1] == '':
				sq.execute('insert into feeds (feed_url) values (?)', (unicode(row[0]),))
			elif row[2] == '' and row[1] != '':
				sq.execute('insert into feeds (feed_url, title) values (?, ?)', (unicode(row[0]), unicode(row[1])))
			elif row[2] == row[0]:
				sq.execute('update feeds set title=? where feed_url=?', (unicode(row[1]), unicode(row[2])))
			else:
				sq.execute('update posts set feed_url=? where feed_url=?', (unicode(row[0]), unicode(row[2])))
				sq.execute('update feeds set title=?, feed_url=? where feed_url=?', (unicode(row[1]), unicode(row[0]), unicode(row[2])))

		sq.commit()
		sq.close()

		self.window.destroy()
		indicator.update_feeds(None, True, True)



##################################################
###############    AppIndicator    ###############
##################################################
class AppIndicator:
	def __init__(self):
		global refreshtime
		global stoptimer
		global itemsperfeed
		global autostart
		global shownotifications
		global usesubmenus

		if gconf['refreshtime'] is not None:
			refreshtime = gconf['refreshtime'];
		else:
			gconf['refreshtime'] = refreshtime;

		if gconf['itemsperfeed'] is not None:
			itemsperfeed = gconf['itemsperfeed'];
		else:
			gconf['itemsperfeed'] = itemsperfeed;

		if gconf['stoptimer'] is not None:
			stoptimer = gconf['stoptimer'];
		else:
			gconf['stoptimer'] = stoptimer;

		if gconf['shownotifications'] is not None:
			shownotifications = gconf['shownotifications'];
		else:
			gconf['shownotifications'] = shownotifications;

		if gconf['usesubmenus'] is not None:
			usesubmenus = gconf['usesubmenus'];
		else:
			gconf['usesubmenus'] = usesubmenus;

		if os.path.exists(app_autostart_file):
			autostart = True

		if not os.path.exists(app_database):
			sq = SQLite()
			sq.open(app_database)
			sq.execute('CREATE TABLE feeds (feed_url TEXT PRIMARY KEY, url TEXT, title TEXT, img TEXT)')
			sq.execute('CREATE TABLE posts (post_url TEXT PRIMARY KEY, title TEXT, read BOOLEAN DEFAULT false, feed_url TEXT NOT NULL, FOREIGN KEY(feed_url) REFERENCES feeds(feed_url))')
			sq.commit()
			sq.close()

		self.ind = appindicator.Indicator(app_name, app_identifier, appindicator.CATEGORY_APPLICATION_STATUS)
		self.ind.set_status(appindicator.STATUS_ACTIVE) #STATUS_PASSIVE = hidden, STATUS_ACTIVE = visible, STATUS_ATTENTION = want the users attention
		self.ind.set_attention_icon(app_indicator_icon_attention)
		self.ind.set_icon(app_indicator_icon)

		self.menu = gtk.Menu()
		self.update_feeds(None, True, True)

	def set_status(self, status):
		"""turns the appindicator to attention and back to normal"""
		if status:
			self.ind.set_status(appindicator.STATUS_ATTENTION)
		else:
			self.ind.set_status(appindicator.STATUS_ACTIVE)

	def send_notification(self, title, message, image):
		"""send feed updates to notify-osd"""
		if not title == None:
			pynotify.init(title)
		if image == None:
			image = 'file://' + app_icon
		n = pynotify.Notification((title if not title == '' else ''), message, image)
		n.set_hint_string('x-canonical-append','')
		n.show()

	def menuitem_response_website(self, data, url):
		"""open the feed's website url"""
		webbrowser.open(url)

	def menuitem_response(self, data, url):
		"""open the website page url"""
		webbrowser.open(url)

		sq = SQLite()
		sq.open(app_database)
		sq.execute('update posts set read =\'true\' where post_url =? ', (url,))
		sq.commit()
		sq.close()

		sleep(1)
		self.render_menu()

	def updates_toggle(self, data):
		"""toggle updating"""
		global stoptimer
		if stoptimer == True:
			stoptimer = False
			gconf['stoptimer'] = False
			if shownotifications:
				self.send_notification(app_name + ' - Started','Feeds will update every ' + str(refreshtime/60) + ' minutes', app_logo)
			self.update_feeds(None, True, True)
		else:
			stoptimer = True
			gconf['stoptimer'] = True
			if shownotifications:
				self.send_notification(app_name + ' - Stopped','Feeds will not update automatically', app_logo)

	def render_menu_empty(self, data):
		"""populate an empty menu"""
		for child in self.menu.get_children():
			child.destroy()
		menu_loading = gtk.MenuItem('Loading ...')
		self.menu.append(menu_loading)
		menu_loading.set_sensitive(False)
		self.menu.show_all()
		self.ind.set_menu(self.menu)
		self.set_status(False)

	def render_menu(self):
		"""populate the menu"""
		global stoptimer

		for child in self.menu.get_children():
			child.destroy()

		sq = SQLite()
		sq.open(app_database)

		feeds = sq.execute('select title, url, feed_url, (select count(*) from posts where posts.feed_url=feeds.feed_url and read=\'false\') as c from feeds order by c desc, title')
		hasfeeds = len(feeds) > 0
		for feed in feeds:
			if usesubmenus == True:
				menu_header = self.create_menu_header(('(' + unicode(feed[3]) + ') ' if not feed[3] == 0 else '') + unicode(feed[0]), '')
				menu_row = self.create_menu_header('Open Website', feed[1])
				submenu = gtk.Menu()
				submenu.append(menu_row)
				submenu_read = gtk.MenuItem('Mark as read')
				submenu_read.connect('activate', self.feed_read, feed[2])
				submenu.append(submenu_read)
				submenu_read = gtk.MenuItem('Mark as unread')
				submenu_read.connect('activate', self.feed_unread, feed[2])
				submenu.append(submenu_read)

				posts = sq.execute(str('select title, post_url from posts where feed_url=? and read == \'false\' limit %i' % itemsperfeed), (feed[2],))
				if len(posts) > 0:
					posts.reverse()
					submenu.append(gtk.SeparatorMenuItem())
				
					for post in posts:
						menu_row = self.create_menu_item(post[0], post[1])
						submenu.append(menu_row)

				menu_header.set_submenu(submenu)
				self.menu.append(menu_header)
			else:
				menu_header = self.create_menu_header(('(' + unicode(feed[3]) + ') ' if not feed[3] == 0 else '') + unicode(feed[0]), feed[1])
				self.menu.append(menu_header)

				posts = sq.execute(str('select title, post_url from posts where feed_url=? and read == \'false\' limit %i' % itemsperfeed), (feed[2],))
				if len(posts) > 0:
					posts.reverse()

					for post in posts:
						menu_row = self.create_menu_item(post[0], post[1])
						self.menu.append(menu_row)

		hasunread = sq.contains('select * from posts where read=\'false\'')

		sq.close()

		if hasfeeds:
			self.menu.append(gtk.SeparatorMenuItem())
			menu_read = gtk.MenuItem('Mark all as read')
			menu_read.connect('activate', self.feed_read, '')
			self.menu.append(menu_read)
			menu_unread = gtk.MenuItem('Mark all as unread')
			menu_unread.connect('activate', self.feed_unread, '')
			self.menu.append(menu_unread)
			menu_update = gtk.MenuItem('Reload all feeds')
			menu_update.connect('activate', self.update_feeds, True, True)
			self.menu.append(menu_update)
			self.menu.append(gtk.SeparatorMenuItem())
			if refreshtime/60 == 1:
				menu_updatecheck = gtk.CheckMenuItem('Update feeds every minute')
			else:
				menu_updatecheck = gtk.CheckMenuItem('Update feeds every ' + str(refreshtime/60) + ' minutes')
			if stoptimer == True:
				menu_updatecheck.set_active(False)
			else:
				menu_updatecheck.set_active(True)
			menu_updatecheck.connect('toggled', self.updates_toggle)
			self.menu.append(menu_updatecheck)
		else:
			menu_notice = gtk.MenuItem('No feeds defined!')
			self.menu.append(menu_notice)
			menu_notice.set_sensitive(False)
			self.menu.append(gtk.SeparatorMenuItem())

		menu_add = gtk.MenuItem('Add feed')
		self.menu.append(menu_add)
		menu_add.connect('activate', AddFeedDialog)
		menu_configure = gtk.MenuItem('Configure ' + app_name)
		self.menu.append(menu_configure)
		menu_configure.connect('activate', ConfigureDialog)
		menu_quit = gtk.MenuItem('Quit')
		self.menu.append(menu_quit)
		menu_quit.connect('activate', Exit)
		self.menu.show_all()
		self.ind.set_menu(self.menu)

		if hasunread:
			self.set_status(True)
		else:
			self.set_status(False)

	def create_menu_header(self, title, url):
		"""create the menu heading for each feed"""
		menu_row = gtk.MenuItem(title)
		if url != '':
			menu_row.connect('activate', self.menuitem_response_website, url)
		return menu_row

	def create_menu_item(self, title, url):
		"""create the menu entries for each feed"""
		if usesubmenus == True:
			menu_row = gtk.MenuItem(title)
		else:
			menu_row = gtk.MenuItem("        " + title)
		menu_row.connect('activate', self.menuitem_response, url)
		return menu_row

	def feed_read(self, data, url):
		"""marks all posts of all feeds or a specific feed as unread"""
		sq = SQLite()
		sq.open(app_database)
		if url == '':
			sq.execute('update posts set read=\'true\'')
		else:
			sq.execute('update posts set read=\'true\' where feed_url=?', (url,))
		sq.commit()
		sq.close()

		sleep(1)
		self.render_menu()

	def feed_unread(self, data, url):
		"""marks all posts of all feeds or a specific feed as read"""
		sq = SQLite()
		sq.open(app_database)
		if url == '':
			sq.execute('update posts set read=\'false\'')
		else:
			sq.execute('update posts set read=\'false\' where feed_url=?', (url,))
		sq.commit()
		sq.close()

		sleep(1)
		self.render_menu()

	def update_feeds(self, data=None, timeroverride=False, starttimer=False):
		"""start updating feeds"""
		global stoptimer

		if stoptimer == True and timeroverride == False:
			return False

		if starttimer:
			glib.timeout_add_seconds(refreshtime, self.update_feeds, True)

		if shownotifications:
			self.send_notification(app_name, 'Feeds will be updated shortly', app_logo)

		self.render_menu_empty(None)
		FeedThread().start()
		return True

	def finnished_update(self):
		"""renders menu and shows notification after FeadThread has endet"""
		self.render_menu()

		if shownotifications:
			sq = SQLite()
			sq.open(app_database)

			feeds = sq.execute('select title, img, feed_url from feeds order by (select count(*) from posts where posts.feed_url=feeds.feed_url and read = \'false\') limit 50') #notification stack is limit to 50

			if len(feeds) > 0:
				for feed in feeds:
					count = 0
					notifymsg = ''
					posts = sq.execute('select title from posts where read = \'false\' and feed_url=?', (feed[2],))

					if len(posts) > 0:
						for post in posts:
							count += 1
							if count > 3:
								break
							notifymsg += '\n' + unicode(post[0])

						if feed[1] == None:
							self.send_notification(feed[0], notifymsg, None)
						else:
							self.send_notification(feed[0], notifymsg, os.path.join(app_cache_dir, feed[1]))
			else:
				self.send_notification(app_name, 'Finnished updating feeds', app_logo)

			sq.close()



##################################################
def main():
	gtk.gdk.threads_init()
	gtk.mainloop()
	return 0

if __name__ == "__main__":
	"""delay to make sure config files are accessible on autostart"""
	cmdline = sys.argv
	if len(cmdline) > 1:
		if cmdline[1] == '--autostarted':
			time.sleep(5)
	if gc.isenabled() == False:
		gc.enable()
	gconf = GConf(app_identifier)
	indicator = AppIndicator()
	main()
